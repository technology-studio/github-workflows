name: "Branch Head Commit Status Check"

on:
  workflow_call:
    inputs:
      branch:
        required: true
        type: string
      check_status_context_pattern_list:
        required: true
        description: Comma separated list of regex patterns of the check status context name
        type: string
      platform:
        required: true
        type: string
      pr_number:
        required: true
        type: number

permissions:
  issues: read
  pull-requests: read
  statuses: write

jobs:
  main:
    name: Check head commit status
    runs-on: ubuntu-latest
    steps:
      - name: Fetch status of head commit on ${{ inputs.branch }} and create commit status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const TRUNK_HEALTH_CHECK_CONTEXT = 'ci/trunk-health/' + '${{ inputs.platform }}';
            const contextPatternList = '${{ inputs.check_status_context_pattern_list }}'.split(',');
            const pullRequestNumber = ${{ inputs.pr_number }};
            const branch = '${{ inputs.branch }}';
            const pullRequest = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pullRequestNumber,
            });
            const prHeadCommit = pullRequest.data.head.sha;
            if (prHeadCommit == null) {
              throw new Error('Could not get PR head commit SHA');
            }

            const defaultCommitStatusOptions = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: prHeadCommit,
              context: TRUNK_HEALTH_CHECK_CONTEXT,
            };

            const isHotfix = pullRequest.data.labels.some(label => label.name === 'hotfix');
            if (isHotfix) {
              console.log('Succeeding the check as the PR is a hotfix.');
              await github.rest.repos.createCommitStatus({
                ...defaultCommitStatusOptions,
                state: 'success',
                description: 'Trunk health check passed (hotfix)',
              });
              return;
            }

            const statuses = await github.rest.repos.listCommitStatusesForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: branch,
              per_page: 100,
            });
            const filteredStatuses = statuses.data.filter(status => (
              contextPatternList.some(pattern => status.context.match(pattern))
            ));

            if (filteredStatuses.length > 0) {
              const newestBuildNumber = filteredStatuses.reduce((acc, status) => {
                const buildNumber = parseInt(status.context.match(/\d+/)[0]);
                return buildNumber > acc ? buildNumber : acc;
              }, 0);

              const newestBuildStatus = filteredStatuses
                .filter(status => status.context.match(/\d+/)[0] === newestBuildNumber.toString())
                .sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at))[0];

              if (newestBuildStatus.state === 'success') {
                await github.rest.repos.createCommitStatus({
                  ...defaultCommitStatusOptions,
                  state: 'success',
                  description: `Trunk health check passed (build ${newestBuildNumber})`,
                });
              } else {
                await github.rest.repos.createCommitStatus({
                  ...defaultCommitStatusOptions,
                  state: 'failure',
                  description: `Trunk health check failed (build ${newestBuildNumber})`,
                });
              }
            } else {
              // add pending check status
              await github.rest.repos.createCommitStatus({
                ...defaultCommitStatusOptions,
                state: 'pending',
                description: 'Trunk health check pending (no statuses found for pattern)',
              });
            }
