name: "Scheduled Bitrise Production Build"

on:
  workflow_call:
    inputs:
      branch_name:
        required: true
        type: string
        default: main
      check_status_context_pattern_list:
        required: true
        description: Comma separated list of regex patterns of the check status context name
        type: string
      bitrise_production_build_workflow_slug:
        required: true
        description: Slug of the Bitrise production build workflow
        type: string
    secrets:
      BITRISE_API_TOKEN:
        required: true
      BITRISE_APP_SLUG:
        required: true

jobs:
  scheduled-bitrise-production-build:
    name: Scheduled Bitrise Production Build
    runs-on: ubuntu-latest
    steps:
      - name: Get latest passing commit SHA
        id: get-latest-passing-commit
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          retries: 3
          script: |
            const contextPatternList = '${{ inputs.check_status_context_pattern_list }}'.split(',')
            const { data: commits } = await github.rest.repos.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.payload.pull_request.head.sha,
              per_page: 100
            })
            let latestPassingCommit = null;
            for (const commit of commits) {
              const { data: statuses } = await github.rest.repos.listCommitStatusesForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: commit.sha,
                per_page: 100,
              });
              const filteredStatuses = statuses.filter(status => (
                contextPatternList.some(pattern => status.context.match(pattern))
              ));

              console.log(`Found ${filteredStatuses.length} statuses for pattern ${contextPatternList} on commit ${commit.sha}: ${filteredStatuses.map(status => status.context)}`);

              if (filteredStatuses.length > 0) {
                const newestBuildNumber = filteredStatuses.reduce((acc, status) => {
                  const buildNumber = parseInt(status.context.match(/\d+/)[0]);
                  return buildNumber > acc ? buildNumber : acc;
                }, 0);
                console.log(`Newest build number on commit ${commit.sha}: ${newestBuildNumber}`);

                const newestBuildStatus = filteredStatuses
                  .filter(status => status.context.match(/\d+/)[0] === newestBuildNumber.toString())
                  .sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at))[0];

                if (newestBuildStatus.state === 'success') {
                  console.log(`Found successful build ${newestBuildNumber} on commit ${commit.sha}`);
                  latestPassingCommit = commit.sha;
                  break;
                }
              }
            }
            if (latestPassingCommit === null) {
              throw new Error('No passing commit found. Exiting.');
            }
            return latestPassingCommit
      - name: Trigger Bitrise production Build
        env:
          BITRISE_API_TOKEN: ${{ secrets.BITRISE_API_TOKEN }}
          BITRISE_APP_SLUG: ${{ secrets.BITRISE_APP_SLUG }}
          BITRISE_PRODUCTION_BUILD_WORKFLOW_SLUG: ${{ inputs.bitrise_production_build_workflow_slug }}
          BRANCH_NAME: ${{ inputs.branch_name }}
          LATEST_PASSING_COMMIT: ${{ steps.get-latest-passing-commit.outputs.result }}
        run: |
          RESPONSE=$(curl -s -X POST \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            -H "Authorization: $BITRISE_API_TOKEN" \
            "https://api.bitrise.io/v0.1/apps/$BITRISE_APP_SLUG/builds" \
            -d '{
              "build_params": {
                "branch": "'"$BRANCH_NAME"'",
                "workflow_id": "'"$BITRISE_PRODUCTION_BUILD_WORKFLOW_SLUG"'",
                "commit_hash": "'"$LATEST_PASSING_COMMIT"'"
              },
              "hook_info": {
                "type": "bitrise"
              }
            }')

          BUILD_SLUG=$(echo $RESPONSE | jq -r '.build_slug')
          BUILD_URL=$(echo $RESPONSE | jq -r '.build_url')

          if [ -z "$BUILD_SLUG" ] || [ "$BUILD_SLUG" = "null" ]; then
            echo "Failed to trigger Bitrise build. Response: $RESPONSE"
            exit 1
          fi

          echo "Bitrise build triggered. Build slug: $BUILD_SLUG"
          echo "Build URL: $BUILD_URL"
